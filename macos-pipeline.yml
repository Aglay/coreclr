parameters:
  buildConfig: ''
  buildConfigUpper: ''
  archType: ''

jobs:

### Product build
- template: /eng/common/templates/phases/base.yml@arcade
  parameters:
    name: ${{ format('mac_{0}_{1}_build', parameters.archType, parameters.buildConfig) }}
    displayName: ${{ format('macOS {0} {1} Build', parameters.archType, parameters.buildConfigUpper) }}
    queue:
      name: Hosted macOS
      timeoutInMinutes: 180
    agentOs: MacOS
    variables:
      buildConfig: ${{ parameters.buildConfig }}
      buildConfigUpper: ${{ parameters.buildConfigUpper }}
      archType: ${{ parameters.archType }}
    steps:
#    - script: brew install cmake # mac machine already has cmake 3.12.2. this command fails, saying:
  #  Error: cmake 3.12.2 is already installed
  #  To upgrade to 3.12.3, run `brew upgrade cmake`
    # - script: brew list icu4c # this fails when it's not installed.
    - script: brew install icu4c
    - script: brew link --force icu4c
    # - script: brew list openssl
    # TODO: do I need to brew link this?
    - script: brew install openssl
#     - task: DotNetCoreInstaller@0
#       inputs:
#         version: 2.1.400
#    - script: eng/common/init-tools-native.sh --installdirectory $(Agent.BuildDirectory)/native-tools -Force
#      displayName: Install native tools
#    - script: bash ./eng/common/init-tools-native.sh --installdirectory $(Agent.BuildDirectory)/native-tools -Force
#      displayName: Install native tools
    - script: ./init-tools.sh
      displayName: Init tools
    - script: ./Tools/dotnetcli/dotnet msbuild build.proj /p:RestoreDuringBuild=true /t:Sync
      displayName: Sync
    - script: ./build.sh $(buildConfig) $(archType)
      displayName: Build

    # Upload build as pipeline artifact
    - task: PublishPipelineArtifact@0
      inputs:
        targetPath: $(Build.SourcesDirectory)\bin\tests\Windows_NT.$(archType).$(buildConfigUpper)

    # Sign
    - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
      - script: echo Sign!
        displayName: Sign Binaries (empty for now)

    # Get key vault secrets for publishing
    - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
      - task: AzureKeyVault@1
        inputs:
          azureSubscription: 'DotNet-Engineering-Services_KeyVault'
          KeyVaultName: EngKeyVault
          SecretsFilter: 'dotnetfeed-storage-access-key-1,microsoft-symbol-server-pat,symweb-symbol-server-pat'

    # Publish packages for official builds
    # - script: NUGET_PACKAGES=$(Build.SourcesDirectory)/.packages .dotnet/dotnet msbuild /t:Restore src/publishwitharcade.proj
    #   displayName: Publish build to some location (empty for now)


### Test build and run
- template: /eng/common/templates/phases/base.yml@arcade
  parameters:
    name: ${{ format('mac_{0}_{1}_test', parameters.archType, parameters.buildConfig) }}
    displayName: ${{ format('macOS {0} {1} Test Build and Run', parameters.archType, parameters.buildConfigUpper) }}
    queue:
      name: Hosted macOS
      timeoutInMinutes: 180
    agentOs: MacOS
    variables:
      buildConfig: ${{ parameters.buildConfig }}
      buildConfigUpper: ${{ parameters.buildConfigUpper }}
      archType: ${{ parameters.archType }}
    steps:
    - script: ./build-test.sh $(buildConfig) $(archType)
      displayName: Build tests
    - script: ./Tools/dotnetcli/dotnet msbuild tests/helixprep.proj /p:CORE_ROOT=$(Build.SourcesDirectory)/bin/tests/OSX.$(archType).$(buildConfigUpper)/Tests/Core_Root /p:__BuildType=$(buildConfig) /p:__BuildArch=$(archType)
      displayName: Prepare test directories for helix
    - task: DotNetCoreCLI@2
      inputs:
        command: custom
        projects: tests/helixpublishwitharcade.proj
        custom: msbuild
        arguments: '/t:test'
      displayName: Send tests job to Helix
      env:
        HelixAccessToken: $(HelixTestAccessToken)
